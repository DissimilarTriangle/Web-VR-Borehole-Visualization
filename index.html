<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <title>VR Video Player with Danmaku</title>
  <script src="https://aframe.io/releases/0.6.0/aframe.min.js"></script>
  <script src="https://unpkg.com/aframe-look-at-component@0.6.0/dist/aframe-look-at-component.min.js"></script>
  <style>
    #upload-button,
    #link-button,
    #exit-button,
    #link-confirm,
    #video-list-button,
    #switch-video-button,

    #print-button,

    #rewind-button,
    #play-button,
    #pause-button,
    #forward-button,
    #mic-button {
      position: fixed;
      font-size: 1.5rem;
      width: 3em;
      height: 3em;
      background-color: #333;
      border-radius: 50%;
      z-index: 10;
      color: #fff;
      border: none;
    }

    /* Top */
    #upload-button {
      top: 10px;
      left: calc(1%);
    }

    #upload-input {
      display: none;
      position: absolute;
      width: 0;
      height: 0;
      opacity: 0;
      overflow: hidden;
    }

    #link-button {
      top: 10px;
      left: calc(1% + 3em);
    }

    #exit-button {
      display: none;
      top: 3.5em;
      left: 10px;
    }

    #link-input {
      position: fixed;
      top: calc(50% + 2em);
      left: calc(50% - 10em);
      width: 20em;
      font-size: 1rem;
      padding: 0.5em;
      z-index: 10;
      display: none;
    }

    #link-confirm {
      top: calc(50% + 2em);
      left: calc(50% + 10em);
      display: none;
    }

    #video-list-button {
      top: 10px;
      left: 10px;
      display: none;
    }

    #switch-video-button {
      top: 10px;
      left: calc(1% + 6em);
    }

    #video-label {
      position: fixed;
      top: 26px;
      left: calc(1% + 15em);
      width: 3.5em;
      height: 2em;
      background-color: #333;
      color: #fff;
      border-radius: 10%;
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 10;
      font-size: 1rem;
      cursor: pointer;
      outline: none;
      border: 1px solid #666;
    }

    #print-button {
      top: 10px;
      right: calc(1% + 1em);
    }

    /* Bottom */
    #rewind-button {
      bottom: 1em;
      left: calc(1%);
    }

    #pause-button {
      bottom: 1em;
      left: calc(1% + 3em);
      display: none;
    }

    #play-button {
      bottom: 1em;
      left: calc(1% + 3em);
    }

    #forward-button {
      bottom: 1em;
      left: calc(1% + 6em);
    }

    #video-controls {
      position: fixed;
      bottom: 50px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
      width: 60%;
    }

    #video-controls input[type="range"] {
      width: 100%;
    }

    #danmaku-input {
      position: fixed;
      bottom: 1em;
      left: calc(50% - 10em);
      width: 20em;
      font-size: 1rem;
      padding: 0.5em;
      z-index: 10;
    }

    #mic-button {
      bottom: 1em;
      right: calc(6em);
    }

    #danmaku-input {
      position: fixed;
      bottom: 1em;
      left: calc(50% - 10em);
      width: 20em;
      font-size: 1rem;
      padding: 0.5em;
      z-index: 10;
    }

    #danmaku-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 10;
    }

    .center-dot {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 10px;
      height: 10px;
      background-color: white;
      border-radius: 50%;
      z-index: 10;
    }

    @media screen and (max-width: 932px) {
      /* Mobile Device e.g iPhone 14 */
      #upload-button,
      #link-button,
      #exit-button,
      #link-confirm,
      #video-list-button,
      #switch-video-button,

      #print-button,

      #rewind-button,
      #play-button,
      #pause-button,
      #forward-button,
      #mic-button {
        width: 2em;
        /* Smaller size */
        height: 2em;
        font-size: 1rem;
      }

      #video-label {
        position: fixed;
        top: 13px;
        left: calc(1% + 9em);
        width: 3.5em;
        height: 1.5em;
        background-color: #333;
        color: #fff;
        border-radius: 10%;
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10;
        font-size: 1rem;
        cursor: pointer;
        outline: none;
        border: 1px solid #666;
      }

      #link-input {
        position: fixed;
        top: calc(50% + 2em);
        left: calc(50% - 9em);
        width: 15em;
        font-size: 1rem;
        padding: 0.5em;
        z-index: 10;
        display: none;
      }

      #video-controls {
        position: fixed;
        bottom: 2.5em;
        left: 50%;
        transform: translateX(-50%);
        z-index: 10;
        width: 60%;
      }

      #danmaku-input {
        position: fixed;
        bottom: 0.5em;
        left: calc(50% - 9em);
        width: 15em;
        font-size: 1rem;
        padding: 0.5em;
        z-index: 10;
      }

    }
  </style>
</head>

<body>
  <button id="play-button">‚ñ∂Ô∏è</button>
  <button id="upload-button">‚è´</button>
  <button id="link-button">üîó</button>
  <button id="exit-button">‚úñ</button>
  <button id="link-confirm">‚úî</button>
  <button id="mic-button">üé§</button>
  <button id="rewind-button">‚è™</button>
  <button id="pause-button">‚è∏Ô∏è</button>
  <button id="forward-button">‚è©</button>
  <button id="print-button">üñ®</button>
  <button id="switch-video-button">üîÑ</button>
  <div id="video-label">vid1</div>
  <button id="video-list-button">üìã</button>
  <input type="file" id="upload-input" accept="video/*" />
  <input type="text" id="link-input" placeholder="Type in video link and enter" />
  <input type="text" id="danmaku-input" placeholder="Type in danmaku and enter" />
  <div id="danmaku-container"></div>
  <div class="center-dot"></div>

  <div id="video-controls">
    <input type="range" id="timeline" value="0" max="100" />
  </div>

  <a-scene id="vr-scene" vr-mode-ui="enabled: true">
    <a-assets>
      <video id="vid1" playsinline crossorigin="anonymous" loop="true" style="display: none"></video>
      <video id="vid2" playsinline crossorigin="anonymous" loop="true" style="display: none"></video>
    </a-assets>

    <a-entity id="video-sphere" geometry="primitive: sphere; radius: 3000; segmentsWidth: 64; segmentsHeight: 64;"
      material="shader: flat; src: #vid1;" scale="-1 1 1" visible="true"></a-entity>

    <a-entity id="camera" camera look-controls position="0 1.6 0">
      <a-cursor fuse="true" fuse-timeout="2000"></a-cursor>
    </a-entity>
  </a-scene>

  <script>
    var vid1 = document.getElementById("vid1");
    var vid2 = document.getElementById("vid2");
    var currentVideoIndex = 1;
    const videos = {
      vid1: document.getElementById('vid1'),
      vid2: document.getElementById('vid2')
    };
    const videoSphere = document.getElementById('video-sphere');

    var uploadButton = document.getElementById("upload-button");
    var uploadInput = document.getElementById("upload-input");
    var linkButton = document.getElementById("link-button");
    var linkInput = document.getElementById("link-input");
    var linkConfirm = document.getElementById("link-confirm");
    var switchVideoButton = document.getElementById("switch-video-button");
    var videoLabel = document.getElementById('video-label');
    var exitButton = document.getElementById("exit-button");
    var printButton = document.getElementById("print-button");

    var playButton = document.getElementById("play-button");
    var pauseButton = document.getElementById("pause-button");
    var rewindButton = document.getElementById("rewind-button");
    var forwardButton = document.getElementById("forward-button");
    var timeline = document.getElementById("timeline");
    var danmakuInput = document.getElementById("danmaku-input");
    var micButton = document.getElementById("mic-button");

    var scene = document.getElementById("vr-scene");
    var currentVideoLink = "";
    var currentInput = "";
    var danmakuList = [];
    var lastTouchTime = 0;
    var touchCount = 0;
    var recognitionActive = false;

    // Set the speed at which the video moves (assuming units of metres per second)
    var videoSpeed = 1.0; // Adjusts to the actual movement speed of the video

    // Connecting to a WebSocket Server (Popup Server)
    var ws = new WebSocket("wss://vrdanmaku.uk:8080");

    ws.onopen = function () {
      console.log("Connected to WebSocket server");
    };

    ws.onmessage = function (event) {
      try {
        var data = JSON.parse(event.data);
        if (data.type === "existing_danmaku") {
          data.data.forEach((danmakuMessage) => {
            addDanmaku(
              danmakuMessage.text,
              danmakuMessage.position,
              danmakuMessage.time
            );
          });
        } else if (data.type === "new_danmaku") {
          addDanmaku(data.data.text, data.data.position, data.data.time);
        }
      } catch (e) {
        console.error("Error parsing message", e);
      }
    };

    ws.onclose = function () {
      console.log("Disconnected from WebSocket server");
    };

    function requestDeviceMotionPermission() {
      if (typeof DeviceMotionEvent.requestPermission === "function") {
        DeviceMotionEvent.requestPermission()
          .then((permissionState) => {
            if (permissionState === "granted") {
              console.log("DeviceMotion permission granted.");
            } else {
              alert("DeviceMotion permission denied.");
            }
          })
          .catch(console.error);
      }
    }

    playButton.addEventListener("click", function (e) {
      requestDeviceMotionPermission();
      const currentVid = currentVideoIndex === 1 ? vid1 : vid2;
      if (!currentVid.src || currentVid.src === window.location.href) {
        alert("Please upload the video or a link to the video first!");
        return;
      }
      this.style.display = "none"; pauseButton.style.display = "block";

      exitButton.style.display = "block";

      currentVid.play();
      startDanmakuMovement(); // Starting danmaku movement
    },
      false
    );

    uploadButton.addEventListener("click", function (e) {
      uploadInput.click();
    },
      false
    );

    uploadInput.addEventListener("change", function (e) {
      var file = e.target.files[0];
      var url = URL.createObjectURL(file);

      currentVideoLink = url;
      playButton.style.display = 'block';

      // Load the video  
      handleVideoLoad(`vid${currentVideoIndex}`, url);

      //  Send the video link to the WebSocket server
      ws.send(JSON.stringify({
        type: 'new_video',
        videoLink: url,
        videoIndex: currentVideoIndex
      }));
    }, false);

    linkButton.addEventListener("click", function (e) {
      linkInput.style.display = "block";
      linkConfirm.style.display = "block";
      linkInput.focus();
    },
      false
    );

    linkInput.addEventListener("keypress", function (e) {
      if (e.key === 'Enter') {
        const url = linkInput.value;
        handleVideoLoad(`vid${currentVideoIndex}`, url);
      }
    });

    linkConfirm.addEventListener(
      "click",
      function (e) {
        var url = linkInput.value;
        if (currentVideoIndex === 1) {
          vid1.src = url;
          vid1.load();
        } else {
          vid2.src = url;
          vid2.load();
        }
        currentVideoLink = url;
        playButton.style.display = "block";
        linkInput.style.display = "none";
        linkConfirm.style.display = "none";

        ws.send(
          JSON.stringify({
            type: "new_video",
            videoLink: url,
            videoIndex: currentVideoIndex,
          })
        );
      },
      false
    );

    danmakuInput.addEventListener("keypress", function (e) {
      if (e.key === "Enter") {
        var text = formatDanmakuText(danmakuInput.value); // Formatting danmaku text
        var camera = document.getElementById("camera"); // Get the a-camera element
        var position = getWorldPosition(camera);
        const currentVid = currentVideoIndex === 1 ? vid1 : vid2;
        addDanmaku(text, position, currentVid.currentTime);
        danmakuInput.value = "";
        // Sending a danmaku to a WebSocket server
        ws.send(
          JSON.stringify({
            type: "new_danmaku",
            text: text,
            position: position,
            videoLink: currentVideoLink,
            time: currentVid.currentTime,
          })
        );
      }
    });

    exitButton.addEventListener("click", function (e) {
      const currentVid = currentVideoIndex === 1 ? vid1 : vid2;
      currentVid.pause();
      vid1.src = "";
      vid2.src = "";
      currentVideoLink = "";
      playButton.style.display = "block";
      uploadButton.style.display = "block";
      linkButton.style.display = "block";
      linkInput.style.display = "block";
      linkConfirm.style.display = "block";
      this.style.display = "none";
    }, false);

    // Video synchronization controller  
    class VideoSyncController {
      constructor(videos) {
        this.videos = videos;
        this.timeline = timeline;
        this.currentVideoIndex = currentVideoIndex;
        this.currentTime = 0;
        this.isPaused = true;
        this.setupSync();
        this.setupTimelineControl();
      }

      setupSync() {
        // sychronize play status
        Object.values(this.videos).forEach(video => {
          video.addEventListener('play', () => this.syncPlay());
          video.addEventListener('pause', () => this.syncPause());
          video.addEventListener('timeupdate', () => this.syncTime(video));

          // synchronize video duration
          video.addEventListener('loadedmetadata', () => {
            console.log(`Video ${video.id} duration:`, video.duration);
            // if current video loaded, update timeline
            if (video === this.getCurrentVideo()) {
              this.updateTimeline();
            }
          });
        });
      }

      //Set timeline control
      setupTimelineControl() {
        // timeline control  
        this.timeline.addEventListener("input", () => {
          const time = (this.timeline.value * this.getCurrentVideo().duration) / 100;
          this.currentTime = time;

          // synchronize time for all videos
          Object.values(this.videos).forEach(video => {
            video.currentTime = time;
          });

          // if danmaku need update the position
          if (typeof updateDanmakuPositions === 'function') {
            updateDanmakuPositions();
          }
        });
      }

      getCurrentVideo() {
        return this.videos[`vid${this.currentVideoIndex}`];
      }

      setCurrentVideoIndex(index) {
        this.currentVideoIndex = index;
        this.updateTimeline();
      }

      syncPlay() {
        if (this.isPaused) {
          Object.values(this.videos).forEach(v => v.play());
          this.isPaused = false;
        }
      }

      syncPause() {
        if (!this.isPaused) {
          Object.values(this.videos).forEach(v => v.pause());
          this.isPaused = true;
        }
      }

      syncTime(sourceVideo) {
        // synchronize time
        const newTime = sourceVideo.currentTime;
        if (Math.abs(this.currentTime - newTime) > 0.1) {
          this.currentTime = newTime;
          Object.values(this.videos).forEach(v => {
            if (v !== sourceVideo && Math.abs(v.currentTime - newTime) > 0.1) {
              v.currentTime = newTime;
            }
          });

          // update timeline
          this.updateTimeline();
        }
      }

      // Update the timeline based on the current video's time
      updateTimeline() {
        const currentVid = this.getCurrentVideo();

        // Make sure the video is loaded and has a valid duration  
        if (currentVid && currentVid.duration && !isNaN(currentVid.duration) && currentVid.duration > 0) {
          // Calculate the percentage of progress (ensure that it is in the range 0-100)  
          const percentage = Math.min(100, Math.max(0, (100 / currentVid.duration) * this.currentTime));

          // update the timeline value
          this.timeline.value = percentage;

          // Logging to aid debugging  
          console.log('Timeline update:', {
            currentVideoIndex: this.currentVideoIndex,
            currentTime: this.currentTime,
            videoDuration: currentVid.duration,
            percentage: percentage
          });
        }
      }
    }

    // Video synchronization controller instance
    const syncController = new VideoSyncController(videos);

    // video load event
    function handleVideoLoad(videoId, url) {
      videos[videoId].src = url;
      videos[videoId].load();
    }

    // Handling touch screen events
    document.body.addEventListener("touchstart", handleTouchStart, false);

    function handleTouchStart(e) {
      if (
        e.target.id === "mic-button" ||
        e.target.id === "rewind-button" ||
        e.target.id === "pause-button" ||
        e.target.id === "forward-button" ||
        e.target.id === "print-button"
      )
        return; // If the microphone button is clicked, skip it

      var currentTime = new Date().getTime();
      if (currentTime - lastTouchTime < 800) {
        // Modify the time window to accommodate quadruple hits
        touchCount++;
      } else {
        touchCount = 1;
      }
      lastTouchTime = currentTime;

      setTimeout(() => {
        const currentVid = currentVideoIndex === 1 ? vid1 : vid2;
        if (touchCount === 1) {
          togglePlayPause();
        } else if (touchCount === 2) {
          currentVid.currentTime += 0.2; // Fast forward 0.2s
        } else if (touchCount === 3) {
          currentVid.currentTime -= 0.2; // Reverse 0.2s
        } else if (touchCount === 4) {
          toggleMic(); // Quadruple-tap to turn the microphone on or off
        }
        updateDanmakuPositions(); // Updating danmaku positions after fast-forwarding or rewinding
        touchCount = 0; // Reset Touch Count
      }, 1000); // Delayed processing of combos to avoid false triggers
    }

    function togglePlayPause() {
      const currentVid = currentVideoIndex === 1 ? vid1 : vid2;
      if (currentVid.paused) {
        currentVid.play();
      } else {
        currentVid.pause();
      }
      updateDanmakuPositions(); // Updates danmaku positions during pause or playback
    }

    function toggleMic() {
      if (!recognitionActive) {
        if (recognition) {
          recognition.start();
          recognitionActive = true;
          micButton.style.backgroundColor = "green"; // Turns green when recording
        }
      } else {
        if (recognition) {
          recognition.stop();
          recognitionActive = false;
          micButton.style.backgroundColor = "red"; // Turns red when recording stops
        }
      }
    }

    function getWorldPosition(camera) {
      var direction = new THREE.Vector3();
      camera.object3D.getWorldDirection(direction);
      direction.multiplyScalar(-2); // Set distance
      var position = camera.object3D.position.clone().add(direction);
      return { x: position.x, y: position.y, z: position.z };
    }


    function addDanmaku(text, position, startTime) {
      // add danmaku to the share list
      danmakuList.push({
        text: text,
        position: position,
        startTime: startTime,
        shown: false
      });

      // send danmaku to the WebSocket server
      ws.send(JSON.stringify({
        type: 'new_danmaku',
        text: text,
        position: position,
        time: startTime,
        videoLinks: {
          vid1: videos.vid1.src,
          vid2: videos.vid2.src
        }
      }));
    }

    function updateDanmakuPositions() {
      var currentTime =
        currentVideoIndex === 1 ? vid1.currentTime : vid2.currentTime;

      danmakuList.forEach(function (danmaku) {
        if (!danmaku.shown && currentTime >= danmaku.startTime) {
          // creat the danmaku background 
          var backgroundEntity = document.createElement('a-plane');
          backgroundEntity.setAttribute('color', 'black');
          backgroundEntity.setAttribute('opacity', 0.5);
          backgroundEntity.setAttribute('width', 1.2);
          backgroundEntity.setAttribute('height', 0.3);
          backgroundEntity.setAttribute('position', danmaku.position);
          backgroundEntity.setAttribute('look-at', '[camera]');
          scene.appendChild(backgroundEntity);

          danmaku.backgroundEntity = backgroundEntity;

          // creat the danmaku text
          var danmakuEntity = document.createElement('a-entity');
          danmakuEntity.setAttribute('text', {
            value: danmaku.text,
            color: 'white',
            align: 'center',
            width: 1,
            wrapCount: 20
          });
          danmakuEntity.setAttribute('position', danmaku.position);
          danmakuEntity.setAttribute('look-at', '[camera]');
          scene.appendChild(danmakuEntity);

          danmaku.entity = danmakuEntity;
          danmaku.shown = true;
        }

        if (danmaku.shown) {
          var elapsedTime = currentTime - danmaku.startTime;
          var distanceTraveled = elapsedTime * videoSpeed;

          var newPosition = {
            x: danmaku.position.x + distanceTraveled,
            y: danmaku.position.y,
            z: danmaku.position.z
          };

          // update danmaku position  
          danmaku.entity.setAttribute('position', newPosition);

          // update background position
          if (danmaku.backgroundEntity) {
            danmaku.backgroundEntity.setAttribute('position', newPosition);
            // damaku look at the camera  
            danmaku.backgroundEntity.setAttribute('look-at', '[camera]');
          }
        }
      });


      
    } 

    function startDanmakuMovement() {
      function move() {
        const currentVid = currentVideoIndex === 1 ? vid1 : vid2;
        if (!currentVid.paused) {
          updateDanmakuPositions();
        }
        requestAnimationFrame(move); // Loop call to make danmaku move during playback
      }
      move(); // Initiate danmaku movement
    }

    // Format danmaku text with line breaks every three words
    function formatDanmakuText(text) {
      var words = text.split(" ");
      for (var i = 3; i < words.length; i += 4) {
        words[i] = words[i] + "\n";
      }
      return words.join(" ");
    }

    // Handling Web Speech API Speech Recognition
    var recognition;
    if ("webkitSpeechRecognition" in window) {
      recognition = new webkitSpeechRecognition();
      recognition.continuous = false;
      recognition.interimResults = false;
      recognition.lang = "en-US";

      recognition.onresult = function (event) {
        var transcript = formatDanmakuText(event.results[0][0].transcript); // Formatting Speech Recognition Text
        var camera = document.getElementById("camera");
        var position = getWorldPosition(camera);
        const currentVid = currentVideoIndex === 1 ? vid1 : vid2;
        addDanmaku(transcript, position, currentVid.currentTime);
        ws.send(
          JSON.stringify({
            type: "new_danmaku",
            text: transcript,
            position: position,
            videoLink: currentVideoLink,
            time: currentVid.currentTime,
          })
        );
      };

      recognition.onerror = function (event) {
        console.error("Speech recognition error", event);
      };
    }

    // Controlling the behaviour of the microphone button
    micButton.addEventListener("click", function () {
      toggleMic();
    });

    // Print danmaku message
    printButton.addEventListener("click", function () {
      var output = "Danmaku Information:\n\n";
      danmakuList.forEach(function (danmaku) {
        output += `Text: ${danmaku.text}, Position: (${danmaku.position.x}, ${danmaku.position.y}, ${danmaku.position.z}), Time: ${danmaku.startTime}s\n`;
      });
      var blob = new Blob([output], { type: "text/plain;charset=utf-8" });
      var link = document.createElement("a");
      link.href = URL.createObjectURL(blob);
      link.download = "danmaku_info.txt";
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    });

    // Bind button function
    rewindButton.addEventListener("click", function () {
      const currentVid = currentVideoIndex === 1 ? vid1 : vid2;
      currentVid.currentTime -= 0.2;
      updateDanmakuPositions();
    });

    pauseButton.addEventListener("click", function () {
      togglePlayPause();
      this.style.display = 'none';
      playButton.style.display = 'block';
    });

    forwardButton.addEventListener("click", function () {
      const currentVid = currentVideoIndex === 1 ? vid1 : vid2;
      currentVid.currentTime += 0.2;
      updateDanmakuPositions();
    });

    switchVideoButton.addEventListener("click", function () {
      currentVideoIndex = currentVideoIndex === 1 ? 2 : 1;

      // Update the video label
      videoLabel.textContent = `vid${currentVideoIndex}`;

      // Switch the video source  
      videoSphere.setAttribute('material', 'src', `#vid${currentVideoIndex}`);

      // Update the danmaku position
      updateDanmakuPositions();
    });

    // Display video label
    videoLabel.addEventListener('blur', function () {
      if (this.textContent.trim() === '') {
        this.textContent = `vid${currentVideoIndex}`;
      }
    });

  </script>
</body>

</html>