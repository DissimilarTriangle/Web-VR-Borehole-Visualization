<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <title>VR Video Player with Annotation</title>
  <script src="https://aframe.io/releases/0.6.0/aframe.min.js"></script>
  <script src="https://unpkg.com/aframe-look-at-component@0.6.0/dist/aframe-look-at-component.min.js"></script>
  <style>
    #link-confirm,
    #switch-video-button,
    #print-button,
    #rewind-button,
    #play-button,
    #pause-button,
    #forward-button,
    #mic-button {
      position: fixed;
      font-size: 1.5rem;
      width: 3em;
      height: 3em;
      background-color: #333;
      border-radius: 50%;
      z-index: 10;
      color: #fff;
      border: none;
    }

    #upload-input {
      display: none;
      position: absolute;
      width: 0;
      height: 0;
      opacity: 0;
      overflow: hidden;
    }

    #link-input {
      position: fixed;
      top: calc(50% + 2em);
      left: calc(50% - 10em);
      width: 20em;
      font-size: 1rem;
      padding: 0.5em;
      z-index: 10;
      display: none;
    }

    #link-confirm {
      top: calc(50% + 2em);
      left: calc(50% + 10em);
      display: none;
    }

    #switch-video-button {
      top: 10px;
      left: 320px;
    }

    #video-label {
      position: fixed;
      top: 26px;
      left: 400px;
      width: 3.5em;
      height: 2em;
      background-color: #333;
      color: #fff;
      border-radius: 10%;
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 10;
      font-size: 1rem;
      cursor: pointer;
      outline: none;
      border: 1px solid #666;
    }

    /*annotation list*/
    #annotation-list-container {
      position: fixed;
      top: 10px;
      right: 10px;
      width: 350px;
      background-color: rgba(0, 0, 0, 0.7);
      color: white;
      border-radius: 5px;
      z-index: 100;
      overflow: hidden;
      max-height: 50vh;
      display: flex;
      flex-direction: column;
    }

    #annotation-list-header {
      padding: 8px;
      background-color: rgba(30, 30, 30, 0.9);
      display: flex;
      justify-content: space-between;
      align-items: center;
      cursor: pointer;
    }

    .header-actions {
      display: flex;
      gap: 10px;
    }

    #annotation-list-toggle {
      background: none;
      border: none;
      color: white;
      font-size: 16px;
      cursor: pointer;
    }

    #annotation-list-content {
      overflow-y: auto;
      max-height: 300px;
      display: none;
    }

    #annotation-table {
      width: 100%;
      border-collapse: collapse;
    }

    #annotation-table th,
    #annotation-table td {
      padding: 6px;
      text-align: left;
      border-bottom: 1px solid #444;
      font-size: 0.9rem;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    #annotation-table tr:nth-child(even) {
      background-color: rgba(50, 50, 50, 0.5);
    }

    #annotation-table tr:hover {
      background-color: rgba(60, 60, 60, 0.8);
      cursor: pointer;
    }

    #annotation-table th:first-child,
    #annotation-table td:first-child {
      width: 20%;
      /* Time column */
    }

    #annotation-table th:last-child,
    #annotation-table td:last-child {
      width: 80%;
      /* Text column */
    }

    #annotation-action-popup {
      position: absolute;
      background-color: rgba(40, 40, 40, 0.9);
      border-radius: 5px;
      padding: 5px;
      display: flex;
      gap: 10px;
      z-index: 101;
    }

    #annotation-action-popup button {
      background: none;
      border: none;
      color: white;
      font-size: 16px;
      width: 30px;
      height: 30px;
      border-radius: 50%;
      cursor: pointer;
    }

    #annotation-delete {
      background-color: #e74c3c;
    }

    #annotation-jump {
      background-color: #3498db;
    }

    .hidden {
      display: none !important;
    }

    #print-button {
      top: 10px;
      right: calc(30%);
    }

    /* Video List */
    #video-list-container {
      position: fixed;
      top: 10px;
      left: 10px;
      width: 300px;
      background-color: rgba(0, 0, 0, 0.7);
      color: white;
      border-radius: 5px;
      z-index: 100;
    }

    #video-list-header {
      padding: 10px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      background-color: rgba(30, 30, 30, 0.9);
      border-bottom: 1px solid #444;
      cursor: pointer;
      border-radius: 5px 5px 0 0;
    }

    #video-list-content {
      max-height: 300px;
      overflow-y: auto;
    }

    #video-table {
      width: 100%;
      border-collapse: collapse;
    }

    #video-table th,
    #video-table td {
      padding: 8px;
      text-align: left;
      border-bottom: 1px solid #444;
    }

    #video-table tr:hover {
      background-color: rgba(60, 60, 60, 0.8);
      cursor: pointer;
    }

    .header-actions button {
      background: none;
      border: none;
      color: white;
      cursor: pointer;
      font-size: 1.2em;
      margin-left: 5px;
    }

    #video-action-popup {
      position: absolute;
      background-color: rgba(40, 40, 40, 0.9);
      border-radius: 5px;
      padding: 5px;
      display: flex;
      gap: 10px;
      z-index: 101;
    }

    #video-action-popup button {
      background: none;
      border: none;
      color: white;
      font-size: 16px;
      width: 30px;
      height: 30px;
      border-radius: 50%;
      cursor: pointer;
    }

    #video-rename {
      background-color: #3498db;
    }

    #video-delete {
      background-color: #e74c3c;
    }

    #video-select-vid1 {
      background-color: #2ecc71;
    }

    #video-select-vid2 {
      background-color: #f39c12;
    }

    .hidden {
      display: none !important;
    }

    .video-tag {
      display: inline-block;
      padding: 2px 5px;
      background-color: #4d4dff;
      border-radius: 3px;
      margin-right: 5px;
    }

    /* Bottom */
    #rewind-button {
      bottom: 1em;
      left: calc(1%);
    }

    #pause-button {
      bottom: 1em;
      left: calc(1% + 3em);
      display: none;
    }

    #play-button {
      bottom: 1em;
      left: calc(1% + 3em);
    }

    #forward-button {
      bottom: 1em;
      left: calc(1% + 6em);
    }

    #video-controls {
      position: fixed;
      bottom: 50px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
      width: 60%;
    }

    #video-controls input[type="range"] {
      width: 100%;
    }

    #annotation-input {
      position: fixed;
      bottom: 1em;
      left: calc(50% - 10em);
      width: 80em;
      font-size: 1rem;
      padding: 0.5em;
      z-index: 10;
    }

    #mic-button {
      bottom: 1em;
      right: calc(6em);
    }

    #annotation-input {
      position: fixed;
      bottom: 1em;
      left: calc(50% - 10em);
      width: 20em;
      font-size: 1rem;
      padding: 0.5em;
      z-index: 10;
    }

    #annotation-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 10;
    }

    .center-dot {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 10px;
      height: 10px;
      background-color: white;
      border-radius: 50%;
      z-index: 10;
    }

    @media screen and (max-width: 932px) {
      /* Mobile Device Size e.g iPhone 14 */

      #link-confirm,
      #switch-video-button,

      #print-button,

      #rewind-button,
      #play-button,
      #pause-button,
      #forward-button,
      #mic-button {
        width: 2.5em;
        height: 2.5em;
        font-size: 1rem;
      }

      #switch-video-button {
        top: 10px;
        left: 260px;
      }

      #print-button {
        top: 10px;
        right: calc(35%);
      }

      #video-list-container {
        width: 230px;
        max-height: 30vh;
      }

      #video-list-header {
        padding: 6px;
        font-size: 0.85rem;
        background-color: rgba(30, 30, 30, 0.9);
        border-bottom: 1px solid #444;
      }

      #video-list-header>span {
        font-size: 0.85rem;
      }

      .header-actions button {
        font-size: 1em;
        margin-left: 3px;
        background: none;
        border: none;
        color: white;
        cursor: pointer;
        width: 22px;
        height: 22px;
        padding: 0;
        display: flex;
        justify-content: center;
        align-items: center;
      }

      #video-table th,
      #video-table td {
        padding: 4px;
        font-size: 0.8rem;
        text-align: left;
        border-bottom: 1px solid #444;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }

      #video-table tr:nth-child(even) {
        background-color: rgba(50, 50, 50, 0.5);
      }

      #video-label {
        position: fixed;
        top: 13px;
        left: 345px;
        width: 3.5em;
        height: 1.5em;
        background-color: #333;
        color: #fff;
        border-radius: 10%;
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10;
        font-size: 1rem;
        cursor: pointer;
        outline: none;
        border: 1px solid #666;
      }

      #annotation-list-container {
        width: 230px;
        max-height: 30vh;
      }

      #annotation-table th,
      #annotation-table td {
        padding: 4px;
        font-size: 0.8rem;
      }

      #link-input {
        position: fixed;
        top: calc(50% + 2em);
        left: calc(50% - 9em);
        width: 15em;
        font-size: 1rem;
        padding: 0.5em;
        z-index: 10;
        display: none;
      }

      #video-controls {
        position: fixed;
        bottom: 2.5em;
        left: 50%;
        transform: translateX(-50%);
        z-index: 10;
        width: 60%;
      }

      #annotation-input {
        position: fixed;
        bottom: 0.5em;
        left: calc(50% - 9em);
        width: 15em;
        font-size: 1rem;
        padding: 0.5em;
        z-index: 10;
      }

      #switch-video-button,
      #print-button,
      #rewind-button,
      #play-button,
      #pause-button,
      #forward-button,
      #mic-button {
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 0;
        line-height: 1;
      }

      #switch-video-button span,
      #print-button span,
      #rewind-button span,
      #play-button span,
      #pause-button span,
      #forward-button span,
      #mic-button span {
        display: block;
        text-align: center;
      }
    }
    
  </style>
</head>

<body>
  <button id="play-button">▶️</button>
  <button id="link-confirm">✔</button>
  <button id="mic-button">🎤</button>
  <button id="rewind-button">⏪</button>
  <button id="pause-button">⏸️</button>
  <button id="forward-button">⏩</button>
  <button id="print-button">🖨</button>
  <button id="switch-video-button">🔄</button>
  <div id="video-label">vid1</div>
  <input type="file" id="upload-input" accept="video/*" />
  <input type="text" id="link-input" placeholder="Type in video link and enter" />
  <input type="text" id="annotation-input" placeholder="Type in annotation and enter" />
  <div id="annotation-container"></div>
  <div class="center-dot"></div>

  <div id="annotation-list-container">
    <div id="annotation-list-header">
      <span>Annotations List</span>
      <div class="header-actions">
        <button id="annotation-list-toggle">▼</button>
      </div>
    </div>
    <div id="annotation-list-content">
      <table id="annotation-table">
        <thead>
          <tr>
            <th>Time</th>
            <th>Text</th>
          </tr>
        </thead>
        <tbody id="annotation-table-body">
          <!-- The annotation table will dynamaically generated here -->
        </tbody>
      </table>
    </div>
  </div>

  <div id="annotation-action-popup" class="hidden">
    <button id="annotation-delete">✖</button>
    <button id="annotation-jump">🚀</button>
  </div>

  <div id="video-list-container">
    <div id="video-list-header">
      <span>Videos List</span>
      <div class="header-actions">
        <button id="upload-button">⏫</button>
        <button id="link-button">🔗</button>
        <button id="video-list-toggle">▼</button>
      </div>
    </div>
    <div id="video-list-content">
      <table id="video-table">
        <thead>
          <tr>
            <th>Name</th>
            <th>Tag</th>
          </tr>
        </thead>
        <tbody id="video-table-body">
          <!-- The video list will be generated dynamically here -->
        </tbody>
      </table>
    </div>
  </div>

  <div id="video-action-popup" class="hidden">
    <button id="video-rename">✏️</button>
    <button id="video-delete">✖</button>
    <button id="video-select-vid1">1️⃣</button>
    <button id="video-select-vid2">2️⃣</button>
  </div>

  <div id="video-controls">
    <input type="range" id="timeline" value="0" max="100" />
  </div>

  <a-scene id="vr-scene" vr-mode-ui="enabled: true">
    <a-assets>
      <video id="vid1" playsinline crossorigin="anonymous" loop="true" style="display: none"></video>
      <video id="vid2" playsinline crossorigin="anonymous" loop="true" style="display: none"></video>
    </a-assets>

    <a-entity id="video-sphere" geometry="primitive: sphere; radius: 3000; segmentsWidth: 64; segmentsHeight: 64;"
      material="shader: flat; src: #vid1;" scale="-1 1 1" visible="true"></a-entity>

    <a-entity id="camera" camera look-controls position="0 1.6 0">
      <a-cursor fuse="true" fuse-timeout="2000"></a-cursor>
    </a-entity>
  </a-scene>

  <script>
    var vid1 = document.getElementById("vid1");
    var vid2 = document.getElementById("vid2");
    var currentVideoIndex = 1;
    const videos = {
      vid1: document.getElementById('vid1'),
      vid2: document.getElementById('vid2')
    };
    const videoSphere = document.getElementById('video-sphere');

    var uploadButton = document.getElementById("upload-button");
    var uploadInput = document.getElementById("upload-input");
    var linkButton = document.getElementById("link-button");
    var linkInput = document.getElementById("link-input");
    var linkConfirm = document.getElementById("link-confirm");
    var switchVideoButton = document.getElementById("switch-video-button");
    var videoLabel = document.getElementById('video-label');
    var printButton = document.getElementById("print-button");

    var playButton = document.getElementById("play-button");
    var pauseButton = document.getElementById("pause-button");
    var rewindButton = document.getElementById("rewind-button");
    var forwardButton = document.getElementById("forward-button");
    var timeline = document.getElementById("timeline");
    var annotationInput = document.getElementById("annotation-input");
    var micButton = document.getElementById("mic-button");

    var scene = document.getElementById("vr-scene");
    var currentVideoLink = "";
    var currentInput = "";
    var annotationList = [];
    var lastTouchTime = 0;
    var touchCount = 0;
    var recognitionActive = false;

    // Set the speed at which the video moves (assuming units of metres per second)
    var videoSpeed = 1.0; // Adjusts to the actual movement speed of the video

    // Connecting to a WebSocket Server
    //var ws = new WebSocket("wss://localhost:8080"); //for local testing
    var ws;
    var wsReconnectTimer;

    function connectWebSocket() {
      ws = new WebSocket("wss://vrdanmaku.uk:8080");

      ws.onopen = function () {
        console.log("Connected to WebSocket server");
        clearTimeout(wsReconnectTimer);

        // Request a video list after successful connection 
        ws.send(JSON.stringify({
          type: 'request_video_list'
        }));
      };

      ws.onclose = function () {
        console.log("Disconnected from WebSocket server, trying to reconnect...");
        wsReconnectTimer = setTimeout(connectWebSocket, 2000);
      };

      ws.onerror = function (err) {
        console.error("WebSocket error:", err);
      };

      ws.onmessage = function (event) {
        try {
          var data = JSON.parse(event.data);
          if (data.type === "existing_annotation") {
            data.data.forEach((annotationMessage) => {
              addAnnotation(
                annotationMessage.text,
                annotationMessage.position,
                annotationMessage.time
              );
            });
          } else if (data.type === "new_annotation") {
            addAnnotation(data.data.text, data.data.position, data.data.time);
          }
        } catch (e) {
          console.error("Error parsing message", e);
        }
      };
    }

    // Initial connection  
    connectWebSocket();

    function requestDeviceMotionPermission() {
      if (typeof DeviceMotionEvent.requestPermission === "function") {
        DeviceMotionEvent.requestPermission()
          .then((permissionState) => {
            if (permissionState === "granted") {
              console.log("DeviceMotion permission granted.");
            } else {
              alert("DeviceMotion permission denied.");
            }
          })
          .catch(console.error);
      }
    }

    playButton.addEventListener("click", function (e) {
      requestDeviceMotionPermission();
      const currentVid = currentVideoIndex === 1 ? vid1 : vid2;
      if (!currentVid.src || currentVid.src === window.location.href) {
        alert("Please upload the video or a link to the video first!");
        return;
      }
      this.style.display = "none"; pauseButton.style.display = "block";

      // exitButton.style.display = "block";

      currentVid.play();
      startAnnotationMovement(); // Starting annotation movement
    },
      false
    );

    annotationInput.addEventListener("keypress", function (e) {
      if (e.key === "Enter") {
        var text = formatAnnotationText(annotationInput.value); // Formatting annotation text
        var camera = document.getElementById("camera"); // Get the a-camera element
        var position = getWorldPosition(camera);
        const currentVid = currentVideoIndex === 1 ? vid1 : vid2;

        annotationInput.value = "";
        // Sending a annotation to a WebSocket server
        ws.send(
          JSON.stringify({
            type: "new_annotation",
            text: text,
            position: position,
            videoLink: currentVideoLink,
            time: currentVid.currentTime,
          })
        );
      }
    });

    // Video synchronization controller  
    class VideoSyncController {
      constructor(videos) {
        this.videos = videos;
        this.timeline = timeline;
        this.currentVideoIndex = currentVideoIndex;
        this.currentTime = 0;
        this.isPaused = true;
        this.setupSync();
        this.setupTimelineControl();
      }

      setupSync() {
        // sychronize play status
        Object.values(this.videos).forEach(video => {
          video.addEventListener('play', () => this.syncPlay());
          video.addEventListener('pause', () => this.syncPause());
          video.addEventListener('timeupdate', () => this.syncTime(video));

          // synchronize video duration
          video.addEventListener('loadedmetadata', () => {
            console.log(`Video ${video.id} duration:`, video.duration);
            // if current video loaded, update timeline
            if (video === this.getCurrentVideo()) {
              this.updateTimeline();
            }
          });
        });
      }

      //Set timeline control
      setupTimelineControl() {
        // timeline control  
        this.timeline.addEventListener("input", () => {
          const time = (this.timeline.value * this.getCurrentVideo().duration) / 100;
          this.currentTime = time;

          // synchronize time for all videos
          Object.values(this.videos).forEach(video => {
            video.currentTime = time;
          });

          // if annotation need update the position
          if (typeof updateAnnotationPositions === 'function') {
            updateAnnotationPositions();
          }
        });
      }

      getCurrentVideo() {
        return this.videos[`vid${this.currentVideoIndex}`];
      }

      setCurrentVideoIndex(index) {
        this.currentVideoIndex = index;
        this.updateTimeline();
      }

      syncPlay() {
        if (this.isPaused) {
          Object.values(this.videos).forEach(v => v.play());
          this.isPaused = false;
        }
      }

      syncPause() {
        if (!this.isPaused) {
          Object.values(this.videos).forEach(v => v.pause());
          this.isPaused = true;
        }
      }

      syncTime(sourceVideo) {
        // synchronize time
        const newTime = sourceVideo.currentTime;
        if (Math.abs(this.currentTime - newTime) > 0.1) {
          this.currentTime = newTime;
          Object.values(this.videos).forEach(v => {
            if (v !== sourceVideo && Math.abs(v.currentTime - newTime) > 0.1) {
              v.currentTime = newTime;
            }
          });

          // update timeline
          this.updateTimeline();
        }
      }

      // Update the timeline based on the current video's time
      updateTimeline() {
        const currentVid = this.getCurrentVideo();

        // Make sure the video is loaded and has a valid duration  
        if (currentVid && currentVid.duration && !isNaN(currentVid.duration) && currentVid.duration > 0) {
          // Calculate the percentage of progress (ensure that it is in the range 0-100)  
          const percentage = Math.min(100, Math.max(0, (100 / currentVid.duration) * this.currentTime));

          // update the timeline value
          this.timeline.value = percentage;

        }
      }
    }

    // Video synchronization controller instance
    const syncController = new VideoSyncController(videos);

    // video load event
    function handleVideoLoad(videoId, url) {
      // Handle relative paths to ensure the use of complete urls 
      if (url.startsWith('/videos/')) {
        url = 'https://vrdanmaku.uk:8080' + url;
      }

      // Set up video source
      if (videoId === 'vid1') {
        vid1.src = url;
        vid1.load();
        currentVideoIndex = 1;
      } else {
        vid2.src = url;
        vid2.load();
        currentVideoIndex = 2;
      }

      currentVideoLink = url;
      playButton.style.display = 'block';

      // Send video loading event to the server 
      ws.send(JSON.stringify({
        type: 'new_video',
        videoLink: url,
        videoIndex: videoId === 'vid1' ? 1 : 2
      }));

      updateVideoTable();
    }

    // Handling touch screen events
    document.body.addEventListener("touchstart", handleTouchStart, false);

    function handleTouchStart(e) {
      if (
        e.target.id === "mic-button" ||
        e.target.id === "rewind-button" ||
        e.target.id === "pause-button" ||
        e.target.id === "forward-button" ||
        e.target.id === "print-button"
      )
        return; // If the microphone button is clicked, skip it

      var currentTime = new Date().getTime();
      if (currentTime - lastTouchTime < 800) {
        // Modify the time window to accommodate quadruple hits
        touchCount++;
      } else {
        touchCount = 1;
      }
      lastTouchTime = currentTime;

      setTimeout(() => {
        const currentVid = currentVideoIndex === 1 ? vid1 : vid2;
        if (touchCount === 1) {
          // do nothing 
        }
        touchCount = 0; // Reset Touch Count
      }, 1000); // Delayed processing of combos to avoid false triggers
    }

    function togglePlayPause() {
      const currentVid = currentVideoIndex === 1 ? vid1 : vid2;
      if (currentVid.paused) {
        currentVid.play();
      } else {
        currentVid.pause();
      }
      updateAnnotationPositions(); // Updates annotation positions during pause or playback
    }

    function toggleMic() {
      if (!recognitionActive) {
        if (recognition) {
          recognition.start();
          recognitionActive = true;
          micButton.style.backgroundColor = "green"; // Turns green when recording
        }
      } else {
        if (recognition) {
          recognition.stop();
          recognitionActive = false;
          micButton.style.backgroundColor = "red"; // Turns red when recording stops
        }
      }
    }

    function getWorldPosition(camera) {
      var direction = new THREE.Vector3();
      camera.object3D.getWorldDirection(direction);
      direction.multiplyScalar(-2); // Set distance
      var position = camera.object3D.position.clone().add(direction);
      return { x: position.x, y: position.y, z: position.z };
    }

    function addAnnotation(text, position, time) {
      // Check if this annotation already exists in the list
      const alreadyExists = annotationList.some(anno =>
        anno.text === text &&
        anno.time === time
      );

      if (!alreadyExists) {
        // Add to local list
        annotationList.push({
          text: text,
          position: position,
          time: time,
          shown: false
        });

        // update the annotation table if it is displayed
        if (annotationListContent.style.display === 'block') {
          updateAnnotationTable();
        }

        // get the current video index
        const currentVid = currentVideoIndex === 1 ? vid1 : vid2;

        // send annotation to the WebSocket server
        ws.send(
          JSON.stringify({
            type: "new_annotation",
            text: text,
            position: position,
            videoLink: currentVideoLink,
            time: currentVid.currentTime,
          })
        );
      }
    }

    function updateAnnotationPositions() {
      var currentTime =
        currentVideoIndex === 1 ? vid1.currentTime : vid2.currentTime;

      annotationList.forEach(function (annotation) {
        if (!annotation.shown && currentTime >= annotation.time) {
          // creat the annotation background 
          var backgroundEntity = document.createElement('a-plane');
          backgroundEntity.setAttribute('color', 'black');
          backgroundEntity.setAttribute('opacity', 0.5);
          backgroundEntity.setAttribute('width', 1.2);
          backgroundEntity.setAttribute('height', 0.3);
          backgroundEntity.setAttribute('position', annotation.position);
          backgroundEntity.setAttribute('look-at', '[camera]');
          scene.appendChild(backgroundEntity);

          annotation.backgroundEntity = backgroundEntity;

          // creat the annotation text
          var annotationEntity = document.createElement('a-entity');
          annotationEntity.setAttribute('text', {
            value: annotation.text,
            color: 'white',
            align: 'center',
            width: 1,
            wrapCount: 20
          });
          annotationEntity.setAttribute('position', annotation.position);
          annotationEntity.setAttribute('look-at', '[camera]');
          scene.appendChild(annotationEntity);

          annotation.entity = annotationEntity;
          annotation.shown = true;
        }

        if (annotation.shown) {
          var elapsedTime = currentTime - annotation.time;
          var distanceTraveled = elapsedTime * videoSpeed;

          var newPosition = {
            x: annotation.position.x + distanceTraveled,
            y: annotation.position.y,
            z: annotation.position.z
          };

          // update annotation position  
          annotation.entity.setAttribute('position', newPosition);

          // update background position
          if (annotation.backgroundEntity) {
            annotation.backgroundEntity.setAttribute('position', newPosition);
            //annotation look at the camera  
            annotation.backgroundEntity.setAttribute('look-at', '[camera]');
          }
        }
      });
    }

    function startAnnotationMovement() {
      function move() {
        const currentVid = currentVideoIndex === 1 ? vid1 : vid2;
        if (!currentVid.paused) {
          updateAnnotationPositions();
        }
        requestAnimationFrame(move); // Loop call to make annotation move during playback
      }
      move(); // Initiate annotation movement
    }

    // Format annotation text with line breaks every three words
    function formatAnnotationText(text) {
      var words = text.split(" ");
      for (var i = 3; i < words.length; i += 4) {
        words[i] = words[i] + "\n";
      }
      return words.join(" ");
    }

    // Handling Web Speech API Speech Recognition
    var recognition;
    if ("webkitSpeechRecognition" in window) {
      recognition = new webkitSpeechRecognition();
      recognition.continuous = false;
      recognition.interimResults = false;
      recognition.lang = "en-US";

      recognition.onresult = function (event) {
        var transcript = formatAnnotationText(event.results[0][0].transcript); // Formatting Speech Recognition Text
        var camera = document.getElementById("camera");
        var position = getWorldPosition(camera);
        const currentVid = currentVideoIndex === 1 ? vid1 : vid2;
        addAnnotation(transcript, position, currentVid.currentTime);
        ws.send(
          JSON.stringify({
            type: "new_annotation",
            text: text,
            position: position,
            videoLink: currentVideoLink,
            time: currentVid.currentTime,
          })
        );
      };

      recognition.onerror = function (event) {
        console.error("Speech recognition error", event);
      };
    }

    // Controlling the behaviour of the microphone button
    micButton.addEventListener("click", function () {
      toggleMic();
    });

    // Print annotation message
    printButton.addEventListener("click", function () {
      var output = "Annotation Information:\n\n";
      annotationList.forEach(function (annotation) {
        output += `Text: ${annotation.text}, Position: (${annotation.position.x}, ${annotation.position.y}, ${annotation.position.z}), Time: ${annotation.time}s\n`;
      });
      var blob = new Blob([output], { type: "text/plain;charset=utf-8" });
      var link = document.createElement("a");
      link.href = URL.createObjectURL(blob);
      link.download = "annotation_info.txt";
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    });

    // Bind button function
    rewindButton.addEventListener("click", function () {
      const currentVid = currentVideoIndex === 1 ? vid1 : vid2;
      currentVid.currentTime -= 0.2;
      updateAnnotationPositions();
    });

    pauseButton.addEventListener("click", function () {
      togglePlayPause();
      this.style.display = 'none';
      playButton.style.display = 'block';
    });

    forwardButton.addEventListener("click", function () {
      const currentVid = currentVideoIndex === 1 ? vid1 : vid2;
      currentVid.currentTime += 0.2;
      updateAnnotationPositions();
    });

    switchVideoButton.addEventListener("click", function () {
      currentVideoIndex = currentVideoIndex === 1 ? 2 : 1;

      // Update the video label
      videoLabel.textContent = `vid${currentVideoIndex}`;

      // Switch the video source  
      videoSphere.setAttribute('material', 'src', `#vid${currentVideoIndex}`);

      // Update the annotation position
      updateAnnotationPositions();
    });

    // Display video label
    videoLabel.addEventListener('blur', function () {
      if (this.textContent.trim() === '') {
        this.textContent = `vid${currentVideoIndex}`;
      }
    });

    // Annotation List functionality
    const annotationListContainer = document.getElementById('annotation-list-container');
    const annotationListHeader = document.getElementById('annotation-list-header');
    const annotationListToggle = document.getElementById('annotation-list-toggle');
    const annotationListContent = document.getElementById('annotation-list-content');
    const annotationTableBody = document.getElementById('annotation-table-body');
    const annotationActionPopup = document.getElementById('annotation-action-popup');
    const annotationDeleteBtn = document.getElementById('annotation-delete');
    const annotationJumpBtn = document.getElementById('annotation-jump');

    let selectedAnnotationIndex = -1;

    // switch the display of annotation list 
    annotationListHeader.addEventListener('click', function (e) {
      if (annotationListContent.style.display === 'block') {
        annotationListContent.style.display = 'none';
        annotationListToggle.textContent = '▼';
      } else {
        annotationListContent.style.display = 'block';
        annotationListToggle.textContent = '▲';
        updateAnnotationTable(); // update the annotation table 
      }
    });

    // update the annotation table
    function updateAnnotationTable() {
      annotationTableBody.innerHTML = '';
      annotationList.forEach((annotation, index) => {
        const row = document.createElement('tr');
        row.dataset.index = index;

        // format the time
        const timeFormatted = formatTime(annotation.time);

        row.innerHTML = `  
      <td>${timeFormatted}</td>  
      <td>${annotation.text.replace(/\n/g, ' ')}</td>  
    `;

        row.addEventListener('click', function (e) {
          selectedAnnotationIndex = parseInt(this.dataset.index);
          showAnnotationActions(e.clientX, e.clientY);
        });

        annotationTableBody.appendChild(row);
      });
    }

    // format time to MM:SS 
    function formatTime(seconds) {
      const mins = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      return `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
    }

    // show the annotation actions popup
    function showAnnotationActions(x, y) {
      annotationActionPopup.classList.remove('hidden');
      annotationActionPopup.style.left = `${x - 40}px`;
      annotationActionPopup.style.top = `${y}px`;

      // close the popup when clicking outside
      document.addEventListener('click', closeAnnotationActionsOnOutsideClick);
    }

    // close the annotation actions popup  
    function closeAnnotationActionsOnOutsideClick(e) {
      if (!annotationActionPopup.contains(e.target) && !e.target.closest('#annotation-table tr')) {
        annotationActionPopup.classList.add('hidden');
        document.removeEventListener('click', closeAnnotationActionsOnOutsideClick);
      }
    }

    // delete the selected annotation
    annotationDeleteBtn.addEventListener('click', function () {
      if (selectedAnnotationIndex >= 0 && selectedAnnotationIndex < annotationList.length) {
        const annotation = annotationList[selectedAnnotationIndex];

        console.log("Deleting annotation:", annotation);

        // send delete annotation message to the server
        const deleteMessage = {
          type: "delete_annotation",
          time: annotation.time,
          text: annotation.text,
        };
        console.log("Sending delete message:", deleteMessage);
        ws.send(JSON.stringify(deleteMessage));

        // remove the annotation entity from the scene
        if (annotation.entity) {
          scene.removeChild(annotation.entity);
        }
        if (annotation.backgroundEntity) {
          scene.removeChild(annotation.backgroundEntity);
        }

        // remove the annotation from the list 
        annotationList.splice(selectedAnnotationIndex, 1);
        updateAnnotationTable();

        // close the action popup
        annotationActionPopup.classList.add('hidden');
      }
    });

    // jump to the selected annotation
    annotationJumpBtn.addEventListener('click', function () {
      if (selectedAnnotationIndex >= 0 && selectedAnnotationIndex < annotationList.length) {
        const annotation = annotationList[selectedAnnotationIndex];
        const currentVid = currentVideoIndex === 1 ? vid1 : vid2;

        // jump to the annotation time
        currentVid.currentTime = annotation.time;

        // update the timeline
        updateAnnotationPositions();

        // close the action popup  
        annotationActionPopup.classList.add('hidden');
      }
    });

    // Video List functionality
    const videoListContainer = document.getElementById('video-list-container');
    const videoListHeader = document.getElementById('video-list-header');
    const videoListToggle = document.getElementById('video-list-toggle');
    const videoListContent = document.getElementById('video-list-content');
    const videoTableBody = document.getElementById('video-table-body');
    const videoActionPopup = document.getElementById('video-action-popup');
    const videoRenameBtn = document.getElementById('video-rename');
    const videoDeleteBtn = document.getElementById('video-delete');
    const videoSelectVid1Btn = document.getElementById('video-select-vid1');
    const videoSelectVid2Btn = document.getElementById('video-select-vid2');
    const videoListUploadBtn = document.getElementById('video-list-upload');
    const videoListLinkBtn = document.getElementById('video-list-link');

    let videoList = [];
    let selectedVideoId = null;

    // Switch video list display
    videoListHeader.addEventListener('click', function (e) {
      if (e.target.tagName === 'BUTTON') return; // Ignore button click 

      if (videoListContent.style.display === 'block') {
        videoListContent.style.display = 'none';
        videoListToggle.textContent = '▼';
      } else {
        videoListContent.style.display = 'block';
        videoListToggle.textContent = '▲';
        updateVideoTable();
      }
    });

    // Display video operation pop-up menu
    function showVideoActions(x, y, videoId) {
      selectedVideoId = videoId;
      videoActionPopup.style.left = x + 'px';
      videoActionPopup.style.top = y + 'px';
      videoActionPopup.classList.remove('hidden');
    }

    // Hide video operation pop-up menu
    document.addEventListener('click', function (e) {
      if (!videoActionPopup.contains(e.target) &&
        !e.target.closest('#video-table tr')) {
        videoActionPopup.classList.add('hidden');
      }
    });

    // Update video table  
    function updateVideoTable() {
      videoTableBody.innerHTML = '';
      videoList.forEach(video => {
        const row = document.createElement('tr');
        row.dataset.id = video.id;

        // Create tag elements
        let tagHtml = '';
        if (video.url === videos.vid1.src) {
          tagHtml += '<span class="video-tag">vid1</span>';
        }
        if (video.url === videos.vid2.src) {
          tagHtml += '<span class="video-tag">vid2</span>';
        }

        row.innerHTML = `  
      <td>${video.name}</td>  
      <td>${tagHtml}</td>  
      <td>⋮</td>  
    `;

        row.addEventListener('click', function (e) {
          showVideoActions(e.clientX, e.clientY, video.id);
        });

        videoTableBody.appendChild(row);
      });
    }

    // Rename the video  
    videoRenameBtn.addEventListener('click', function () {
      const video = videoList.find(v => v.id === selectedVideoId);
      if (video) {
        const newName = prompt('Enter new name:', video.name);
        if (newName && newName.trim() !== '') {
          ws.send(JSON.stringify({
            type: 'update_video_name',
            videoId: selectedVideoId,
            newName: newName.trim()
          }));
        }
      }
      videoActionPopup.classList.add('hidden');
    });

    // Delete the video  
    videoDeleteBtn.addEventListener('click', function () {
      if (confirm('Are you sure you want to delete this video?')) {
        ws.send(JSON.stringify({
          type: 'delete_video',
          videoId: selectedVideoId
        }));
      }
      videoActionPopup.classList.add('hidden');
    });

    // Choose the video as vid1
    videoSelectVid1Btn.addEventListener('click', function () {
      const video = videoList.find(v => v.id === selectedVideoId);
      if (video) {
        handleVideoLoad('vid1', video.url);
        videoActionPopup.classList.add('hidden');
      }
    });

    // Choose the video as vid2 
    videoSelectVid2Btn.addEventListener('click', function () {
      const video = videoList.find(v => v.id === selectedVideoId);
      if (video) {
        handleVideoLoad('vid2', video.url);
        videoActionPopup.classList.add('hidden');
      }
    });

    uploadButton.addEventListener("click", function (e) {
      uploadInput.click();
    },
      false
    );

    uploadInput.addEventListener("change", function (e) {
      var file = e.target.files[0];
      if (!file) return;

      // Create a FormData object to send the file 
      const formData = new FormData();
      formData.append('video', file);
      formData.append('name', file.name);

      // Send upload request -with detailed debugging information  
      fetch('https://vrdanmaku.uk:8080/upload', {
        method: 'POST',
        body: formData,
        signal: AbortSignal.timeout(60000), // 60s timeout
        credentials: 'include', //Cross-domain credential support
        mode: 'cors' // Clearly set cross-domain mode
      })
        .then(response => {
          console.log("Response status:", response.status);
          if (!response.ok) {
            throw new Error(`HTTP error: ${response.status}`);
          }
          return response.text().then(text => {
            try {
              return JSON.parse(text);
            } catch (e) {
              console.error("JSON parse error:", e, "Response was:", text);
              throw new Error("Server response was not valid JSON");
            }
          });
        })
        .then(data => {
          console.log("Upload success:", data);
          // Request the video list to ensure UI is updated 
          if (ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({ type: 'request_video_list' }));
          }
          if (data.success) {
            handleVideoLoad('vid1', data.video.url);
          }
        })
        .catch(error => {
          console.error('Upload error:', error);
          alert('Upload failed: ' + error.message);
        });

      this.value = ''; // Reset the input box 
    }, false);

    linkButton.addEventListener("click", function (e) {
      linkInput.style.display = "block";
      linkConfirm.style.display = "block";
      linkInput.focus();
    },
      false
    );

    linkInput.addEventListener("keypress", function (e) {
      if (e.key === 'Enter') {
        const url = linkInput.value;
        handleVideoLoad(`vid${currentVideoIndex}`, url);
      }
    });

    linkConfirm.addEventListener(
      "click",
      function (e) {
        var url = linkInput.value;
        if (currentVideoIndex === 1) {
          vid1.src = url;
          vid1.load();
        } else {
          vid2.src = url;
          vid2.load();
        }
        currentVideoLink = url;
        playButton.style.display = "block";
        linkInput.style.display = "none";
        linkConfirm.style.display = "none";

        ws.send(
          JSON.stringify({
            type: "new_video",
            videoLink: url,
            videoIndex: currentVideoIndex,
          })
        );
      },
      false
    );

    // Process video loading
    function handleVideoLoad(videoId, url) {
      // Set up video source
      if (videoId === 'vid1') {
        vid1.src = url;
        vid1.load();
        currentVideoIndex = 1;
      } else {
        vid2.src = url;
        vid2.load();
        currentVideoIndex = 2;
      }

      currentVideoLink = url;
      playButton.style.display = 'block';

      // Send video loading event to the server 
      ws.send(JSON.stringify({
        type: 'new_video',
        videoLink: url,
        videoIndex: videoId === 'vid1' ? 1 : 2
      }));

      updateVideoTable();
    }

    // WebSocket processing  
    ws.onmessage = function (event) {
      try {
        var data = JSON.parse(event.data);
        if (data.type === "existing_annotation") {
          annotationList = []; // Clear existing annotations before adding new ones 
          // Add annotations sent by the server
          data.data.forEach((annotationMessage) => {
            // Add to local list only
            annotationList.push({
              text: annotationMessage.text,
              position: annotationMessage.position,
              time: annotationMessage.time,
              shown: false
            });
          });
          updateAnnotationTable();
        } else if (data.type === "new_annotation") {
          // New annotations received from the server are added to the local list only
          annotationList.push({
            text: data.data.text,
            position: data.data.position,
            time: data.data.time,
            shown: false
          });
          updateAnnotationTable();
        } else if (data.type === "annotation_deleted") {
          annotationList.splice(data.data.index, 1); // Delete items in the local annotation list 
          updateAnnotationTable();
          updateAnnotationPositions();
        } else if (data.type === "video_list") {
          videoList = data.data;
          updateVideoTable();
        } else if (data.type === "video_loaded") {
          // Handle videos loaded by other clients 
          const videoId = data.videoIndex === 1 ? 'vid1' : 'vid2';

          // Automatically load only if the video is not currently played
          if (!vid1.src && !vid2.src) {
            handleVideoLoad(videoId, data.videoLink);
          }
        }
      } catch (e) {
        console.error("Error parsing message", e);
      }
    };

    // Request a list of videos when the page loads 
    window.addEventListener('load', function () {
      ws.send(JSON.stringify({
        type: 'request_video_list'
      }));
    });

  </script>
</body>

</html>